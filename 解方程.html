<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>解方程器</title>
  <link rel="icon" href="https://user-assets.sxlcdn.com/images/1209238/FlWuslNmGTHt1EipxUtq2GI6zqnN.png?imageMogr2/strip/auto-orient/thumbnail/1200x9000%3E/quality/90!/format/png" type="image/png">
  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
  <!-- math.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
  <style>
    body {
      font-family: 'Roboto', sans-serif;
      background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
      height: 100vh;
      margin: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      animation: backgroundAnimation 15s infinite alternate;
    }
    @keyframes backgroundAnimation {
      0% { background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%); }
      100% { background: linear-gradient(135deg, #ff7e5f 0%, #feb47b 100%); }
    }
    .container {
      background: rgba(255, 255, 255, 0.1);
      padding: 30px 40px;
      border-radius: 15px;
      box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
      backdrop-filter: blur(8.5px);
      -webkit-backdrop-filter: blur(8.5px);
      border: 1px solid rgba(255, 255, 255, 0.18);
      color: #ffffff;
      width: 92%;
      max-width: 560px;
      text-align: center;
      animation: fadeIn 0.9s ease-in-out;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(-18px); }
      to { opacity: 1; transform: translateY(0); }
    }
    h1 {
      margin: 0 0 12px;
      font-size: 2rem;
      text-shadow: 2px 2px 4px rgba(0,0,0,.45);
      letter-spacing: .5px;
    }
    .hint {
      margin-top: 6px;
      font-size: 0.9rem;
      opacity: .9;
    }
    .form-group { margin: 18px 0 14px; text-align: left; }
    label {
      display: block;
      margin-bottom: 8px;
      font-weight: 700;
      color: #ffffff;
    }
    input[type="text"] {
      width: 100%;
      padding: 12px 15px;
      border: none;
      border-radius: 8px;
      box-sizing: border-box;
      font-size: 1.05rem;
      transition: box-shadow .25s ease;
    }
    input[type="text"]::placeholder { color: rgba(0,0,0,.35); }
    input[type="text"]:focus {
      outline: none;
      box-shadow: 0 0 12px rgba(255, 255, 255, 0.7);
    }
    button {
      width: 100%;
      padding: 12px;
      background: linear-gradient(45deg, #ff6a00, #ee0979);
      border: none;
      border-radius: 8px;
      color: #ffffff;
      font-size: 1.1rem;
      font-weight: bold;
      cursor: pointer;
      transition: transform .18s, box-shadow .18s, opacity .18s;
    }
    button:hover { transform: translateY(-3px); box-shadow: 0 4px 15px rgba(255,106,0,.4); }
    button:active { transform: translateY(1px); box-shadow: 0 2px 10px rgba(255,106,0,.4); }
    button:disabled { opacity: .7; cursor: not-allowed; }
    .result, .error, .info {
      margin-top: 18px;
      padding: 14px 15px;
      border-radius: 8px;
      font-size: 1rem;
      line-height: 1.55;
      animation: slideIn .45s ease-in-out;
      text-align: left;
      word-break: break-word;
      white-space: pre-wrap;
    }
    .result { background-color: rgba(34,193,195,.85); border-left: 6px solid #22c1c3; color: #fff; }
    .error  { background-color: rgba(255, 0, 0, .78); border-left: 6px solid #ff0000; color: #fff; }
    .info   { background-color: rgba(255,255,255, .22); border-left: 6px solid rgba(255,255,255, .65); color: #fff; }
    @keyframes slideIn {
      from { opacity: 0; transform: translateY(10px); }
      to   { opacity: 1; transform: translateY(0); }
    }
    .foot {
      margin-top: 10px;
      font-size: .9rem;
      opacity: .9;
      text-align: left;
    }
    code.kbd {
      background: rgba(255,255,255,.25);
      padding: 1px 6px;
      border-radius: 5px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>解方程器</h1>
    <div class="hint">支持：隐式乘法（<code>2x</code>）、函数（<code>sqrt</code>、<code>sin</code>、…）、Unicode 上标（<code>x²</code>）。仅返回实数解。</div>

    <div class="form-group">
      <label for="equation">输入方程：</label>
      <input type="text" id="equation" placeholder="例如：2x + 3 = 0、x² - 3x + 2 = 0、sqrt(x-9) = 0、sin(x)=0">
    </div>
    <button id="solveBtn">解 方程</button>

    <div id="output" class="info">提示：按 <code class="kbd">Enter</code> 也可求解。</div>

    <div class="foot">
      注意：若方程对所有实数恒成立会显示“无数解”；若为矛盾等式（如 <code>2=3</code>）则“无解”。复杂方程仅做实根数值求解。
    </div>
  </div>

  <script>
    // ---------- 可调参数 ----------
    const SOLVER = {
      minInit: -1000,       // 初始扫描下界
      maxInit:  1000,       // 初始扫描上界
      refineTol: 1e-10,     // 收敛容差（函数值）
      mergeTol: 1e-7,       // 根去重阈值
      samplePoints: 4000,   // 扫描采样点数（越大越稳，越慢）
      maxExpansions: 6,     // 最多扩展几次扫描区间
      nearZeroHint: 1e-6,   // 近零阈值（触发牛顿法）
      maxNewtonSteps: 30,   // 牛顿法最大迭代步
      maxBisectionSteps: 80,// 二分/夹逼最大步数
      maxRoots: 100         // 安全阈值：最多返回多少个根
    };

    // 一些常量&函数名集合，帮助处理隐式乘法和变量识别
    const KNOWN_CONSTS = new Set([
      'e','pi','tau','phi','E','PI','TAU','Infinity','NaN','i','I','true','false','null'
    ]);
    const KNOWN_FUNCS = new Set([
      // 常见初等函数
      'sin','cos','tan','cot','sec','csc',
      'asin','acos','atan','acot','asec','acsc',
      'sinh','cosh','tanh','asinh','acosh','atanh',
      'exp','log','ln','log10','log2',
      'sqrt','cbrt','abs','sign',
      'ceil','floor','round','trunc',
      'min','max','sum','prod','mean','median','mode','std','variance','mad',
      'pow','hypot','atan2',
      're','im','arg','conj',
      'mod','gcd','lcm',
      'factorial','gamma','erf',
      'nthroot','root',
      // 其他 math.js 里常用的
      'unit','complex','matrix','det','inv','transpose','trace','size'
    ]);

    // 绑定事件
    document.getElementById('solveBtn').addEventListener('click', solveEquation);
    document.getElementById('equation').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') solveEquation();
    });

    function solveEquation() {
      const out = document.getElementById('output');
      const btn = document.getElementById('solveBtn');
      const raw = document.getElementById('equation').value;

      clearOutput();

      if (!raw || raw.trim() === '') return showError('请输入一个方程。');

      btn.disabled = true;

      try {
        // 1) 预处理输入
        const normalized = preprocessEquation(raw);

        // 2) 必须且只允许一个“=”
        const parts = normalized.split('=');
        if (parts.length !== 2) {
          showError('方程格式不正确：必须且只能包含一个“=”。');
          btn.disabled = false; return;
        }
        const left = parts[0], right = parts[1];

        // 3) 组合为 f(x)=0
        const exprStr = `(${left}) - (${right})`;

        // 4) 解析 AST 并识别变量
        let node;
        try { node = math.parse(exprStr); }
        catch (err) { showError('无法解析表达式，请检查括号/运算符是否正确。'); btn.disabled=false; return; }

        const variables = detectVariables(node);
        if (variables.size === 0) {
          // 常数等式：直接判定
          const val = safeEval(node, {});
          if (isFiniteNumber(val) && Math.abs(val) < SOLVER.refineTol) {
            showResult('方程对所有实数都成立，无数解。'); btn.disabled = false; return;
          }
          showError('方程为常数等式且不成立，故无解。'); btn.disabled = false; return;
        }
        if (variables.size > 1) {
          showError(`检测到多个变量：${Array.from(variables).join(', ')}。目前仅支持单变量方程。`);
          btn.disabled = false; return;
        }
        const variable = Array.from(variables)[0];

        // 5) 编译 f(x) 与 f'(x)
        const compiled = node.compile();
        let derivCompiled = null;
        try {
          const dnode = math.derivative(node, variable);
          derivCompiled = dnode.compile();
        } catch (_) {
          derivCompiled = null; // 某些函数不可导时，后续会自动降级
        }

        const f = (x) => safeEvalCompiled(compiled, variable, x);
        const df = derivCompiled ? (x) => safeEvalCompiled(derivCompiled, variable, x) : null;

        // 6) 恒等 0 检测（可靠版）
        if (isAlwaysZero(f)) {
          showResult('方程对所有实数都成立，无数解。'); btn.disabled=false; return;
        }

        // 7) 数值判定是否线性，并在可行时给出解析解
        const linRes = trySolveLinearNumerically(f);
        if (linRes.status === 'linear') {
          if (linRes.a === 0 && Math.abs(linRes.b) < SOLVER.refineTol) {
            showResult('方程对所有实数都成立，无数解。'); btn.disabled=false; return;
          }
          if (linRes.a === 0) {
            showError('方程无解。'); btn.disabled=false; return;
          }
          const root = -linRes.b / linRes.a;
          const pretty = formatNumber(root);
          showResult(`实数解：${variable} = ${pretty}`);
          btn.disabled = false; return;
        }

        // 8) 扫描+夹逼+牛顿，寻找所有实根
        const roots = solveRealRoots(f, df);
        if (roots.length === 0) {
          showError('未找到实数解。');
          btn.disabled = false; return;
        }

        const list = roots.map(formatNumber);
        showResult(`实数解：${variable} = ${list.join('，')}`);
      } catch (err) {
        console.error(err);
        showError('求解时发生错误，请检查输入格式或尝试简化方程。');
      } finally {
        btn.disabled = false;
      }
    }

    // ----------------- 预处理与解析 -----------------

    function preprocessEquation(input) {
      // 标准化：去空白 -> 替换本地化字符 -> 处理上标 -> 插入隐式乘号 -> 标准幂符号
      let s = input.trim();

      // 全角/本地化与符号统一
      s = s
        .replace(/（/g, '(').replace(/）/g, ')')
        .replace(/【/g, '[').replace(/】/g, ']')
        .replace(/，/g, ',')
        .replace(/[＋+]/g, '+')
        .replace(/[－–—−]/g, '-') // 各种减号
        .replace(/[×·•⋅]/g, '*')
        .replace(/÷/g, '/');

      // 幂的 JS 写法 -> 数学写法
      s = s.replace(/\*\*/g, '^');

      // 去多余空白
      s = s.replace(/\s+/g, '');

      // 把 Unicode 上标（⁰¹²³⁴⁵⁶⁷⁸⁹ 以及 ²³¹）转成 ^(digits)
      s = convertSuperscriptsToPowers(s);

      // 插入隐式乘号（注意不要破坏函数调用，如 sin(x) 不能变成 s*i*n*(x)）
      s = insertImplicitMultiplication(s);

      return s;
    }

    function convertSuperscriptsToPowers(s) {
      const map = {'⁰':'0','¹':'1','²':'2','³':'3','⁴':'4','⁵':'5','⁶':'6','⁷':'7','⁸':'8','⁹':'9'};
      // 把形如 aⁿ 或 )ⁿ 或 数字ⁿ 变为 a^(n)
      return s.replace(/([A-Za-z0-9\)\]])([⁰¹²³⁴⁵⁶⁷⁸⁹]+)/g, (_, base, sup) => {
        const digits = sup.split('').map(ch => map[ch] ?? '').join('');
        return `${base}^(${digits})`;
      });
    }

    function insertImplicitMultiplication(s) {
      // 1) 数字 与 变量/括号: 2x -> 2*x, 3(x+1)->3*(x+1)
      s = s.replace(/(\d)([A-Za-z_\(])/g, '$1*$2');

      // 2) 括号) 与 数字/变量: (x+1)2 -> (x+1)*2, (x) y -> (x)*y
      s = s.replace(/(\))(\d|[A-Za-z_])/g, '$1*$2');

      // 3) 变量名 token 与 "("：仅在 token 不是函数名时插入乘号
      s = s.replace(/([A-Za-z_][A-Za-z0-9_]*)\(/g, (m, name) => {
        const lname = name.toLowerCase();
        return KNOWN_FUNCS.has(lname) ? `${name}(` : `${name}*(`;
      });

      return s;
    }

    function detectVariables(astNode) {
      const set = new Set();
      (function walk(n) {
        if (!n || typeof n !== 'object') return;
        switch (n.type) {
          case 'SymbolNode':
            set.add(n.name);
            break;
          case 'FunctionNode':
            // 只遍历参数，跳过 n.fn，避免把函数名当作变量
            n.args.forEach(walk);
            break;
          case 'ParenthesisNode':
            walk(n.content);
            break;
          case 'AccessorNode':
            walk(n.object);
            walk(n.index);
            break;
          default:
            if (Array.isArray(n.args)) n.args.forEach(walk);
        }
      })(astNode);

      // 过滤内建常量与已知函数名
      for (const name of Array.from(set)) {
        const lname = String(name).toLowerCase();
        if (KNOWN_CONSTS.has(name) || KNOWN_CONSTS.has(lname) || KNOWN_FUNCS.has(lname)) {
          set.delete(name);
        }
      }
      return set;
    }

    // ----------------- 安全求值 -----------------

    function isFiniteNumber(x) { return typeof x === 'number' && isFinite(x); }

    function toNumber(val) {
      if (isFiniteNumber(val)) return val;
      // math.js Complex
      if (val && typeof val === 'object' && 're' in val && 'im' in val) {
        return Math.abs(val.im) < 1e-14 ? val.re : NaN;
      }
      return NaN;
    }

    function safeEval(astNode, scope) {
      try { return toNumber(astNode.compile().evaluate(scope)); }
      catch (_) { return NaN; }
    }

    function safeEvalCompiled(compiled, variable, x) {
      const scope = {}; scope[variable] = x;
      try { return toNumber(compiled.evaluate(scope)); }
      catch (_) { return NaN; }
    }

    // ----------------- 判定恒等/线性 -----------------

    function isAlwaysZero(f) {
      const pts = [-2, -1, 0, 1, 2, 10];
      let count = 0;
      for (const t of pts) {
        const v = f(t);
        if (isFiniteNumber(v)) {
          if (Math.abs(v) > 1e-9) return false;
          count++;
        }
      }
      return count >= 4; // 至少 4 个有限点近 0 才信
    }

    function trySolveLinearNumerically(f) {
      // 选择 3 个点，检查二阶差分是否近 0：线性 <=> f(0)-2f(1)+f(2) ~ 0
      const candidates = [
        [0,1,2],
        [-1,0,1],
        [1,2,3]
      ];
      for (const [a,b,c] of candidates) {
        const fa = f(a), fb = f(b), fc = f(c);
        if ([fa,fb,fc].every(isFiniteNumber)) {
          const second = fa - 2*fb + fc;
          if (Math.abs(second) < 1e-8) {
            const A = fb - fa;   // 近似斜率
            const B = fa;        // 截距
            return { status: 'linear', a: A, b: B };
          }
        }
      }
      return { status: 'nonlinear' };
    }

    // ----------------- 求根（扫描 + 夹逼 + 牛顿） -----------------

    function solveRealRoots(f, df) {
      let min = SOLVER.minInit, max = SOLVER.maxInit;
      const roots = [];

      for (let expand = 0; expand <= SOLVER.maxExpansions; expand++) {
        const brackets = [];
        const nearZeros = [];

        // 扫描
        const N = SOLVER.samplePoints;
        const step = (max - min) / N;
        let xPrev = null, fPrev = null;

        for (let i = 0; i <= N; i++) {
          const x = min + i * step;
          const fx = f(x);

          if (isFiniteNumber(fx)) {
            // 捕获近零点提示（重根/平台根）
            if (Math.abs(fx) < SOLVER.nearZeroHint) {
              nearZeros.push(x);
            }
            // 捕获符号变化（普通根）
            if (xPrev !== null && isFiniteNumber(fPrev) && fPrev * fx <= 0) {
              brackets.push([xPrev, x]);
            }
            xPrev = x; fPrev = fx;
          } else {
            // 断点：重置前一个点
            xPrev = null; fPrev = null;
          }
        }

        // 先用夹逼法 refine
        for (const [a,b] of brackets) {
          const r = refineBracket(f, a, b);
          if (r !== null) roots.push(r);
          if (roots.length >= SOLVER.maxRoots) break;
        }

        // 再用牛顿法从近零点出发（抓重根/切触）
        for (const x0 of nearZeros) {
          const r = newtonRefine(f, df, x0, step);
          if (r !== null) roots.push(r);
          if (roots.length >= SOLVER.maxRoots) break;
        }

        // 去重
        const uniq = dedupeRoots(roots);
        if (uniq.length > 0) return uniq;

        // 没找到根则扩大区间再试
        const range = (max - min);
        min -= range;
        max += range;
      }
      return dedupeRoots(roots);
    }

    function refineBracket(f, a0, b0) {
      let a = a0, b = b0;
      let fa = f(a), fb = f(b);
      if (!isFiniteNumber(fa) || !isFiniteNumber(fb)) return null;

      // 端点即根
      if (Math.abs(fa) < SOLVER.refineTol) return a;
      if (Math.abs(fb) < SOLVER.refineTol) return b;

      if (fa * fb > 0) return null; // 没有符号变化

      let mid = null, fmid = null;
      for (let i = 0; i < SOLVER.maxBisectionSteps; i++) {
        mid = 0.5 * (a + b);
        fmid = f(mid);
        if (!isFiniteNumber(fmid)) { // 中点不可用时轻微偏移
          mid = (3*a + b)/4;
          fmid = f(mid);
          if (!isFiniteNumber(fmid)) return null;
        }

        if (Math.abs(fmid) < SOLVER.refineTol) return mid;
        if (fa * fmid < 0) {
          b = mid; fb = fmid;
        } else {
          a = mid; fa = fmid;
        }
      }
      // 校验中点是否真的接近 0，防极点误报
      if (isFiniteNumber(fmid) && Math.abs(fmid) < 1e-7) return mid;
      return null;
    }

    function newtonRefine(f, df, x0, h) {
      // 无导数则降级为“微小区间二分”
      if (!df) {
        const a = x0 - 2*h, b = x0 + 2*h;
        return refineBracket(f, a, b);
      }

      let x = x0;
      for (let i = 0; i < SOLVER.maxNewtonSteps; i++) {
        const fx = f(x);
        const dfx = df(x);
        if (!isFiniteNumber(fx) || !isFiniteNumber(dfx)) return null;
        if (Math.abs(fx) < SOLVER.refineTol) return x;
        if (Math.abs(dfx) < 1e-14) return null; // 斜率过小
        const x1 = x - fx/dfx;
        if (!isFiniteNumber(x1)) return null;
        if (Math.abs(x1 - x) < 1e-12) return Math.abs(f(x1)) < 1e-7 ? x1 : null;
        x = x1;
      }
      return Math.abs(f(x)) < 1e-7 ? x : null;
    }

    function dedupeRoots(arr) {
      const a = arr.filter(isFiniteNumber).slice().sort((p,q)=>p-q);
      const out = [];
      for (const x of a) {
        if (out.length === 0 || Math.abs(x - out[out.length-1]) > SOLVER.mergeTol) {
          out.push(x);
        }
      }
      // 去 -0
      return out.map(v => (Object.is(v, -0) ? 0 : v));
    }

    function formatNumber(x) {
      if (!isFiniteNumber(x)) return String(x);
      if (Math.abs(x) < 1e-12) return '0';
      // 使用 math.format 提供稳定输出（避免 1.0000000002 这类）
      return math.format(x, { precision: 12, lowerExp: -8, upperExp: 14 });
    }

    // ----------------- UI 辅助 -----------------

    function clearOutput() { document.getElementById('output').innerHTML = ''; }
    function showResult(msg) { document.getElementById('output').innerHTML = `<div class="result">${msg}</div>`; }
    function showError(msg) { document.getElementById('output').innerHTML = `<div class="error">${msg}</div>`; }

  </script>
</body>
</html>