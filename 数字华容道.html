<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>æ•°å­—åå®¹é“</title>
<link rel="icon" href="https://user-assets.sxlcdn.com/images/1209238/FlWuslNmGTHt1EipxUtq2GI6zqnN.png?imageMogr2/strip/auto-orient/thumbnail/1200x9000%3E/quality/90!/format/png" type="image/png" />
<style>
@import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
:root{
  --bg1:#1b1a17;
  --bg2:#111014;
  --paper:#f7f1d5;
  --paper2:#efe3b0;
  --ink:#1b1a17;
  --accent:#ffb000;
  --accent2:#ff3b7a;
  --good:#00d084;
  --warn:#ffcc00;
  --bad:#ff4d4d;
  --grid:#2b2a2f;
  --tile:#f7f1d5;
  --tile2:#f2e7b9;
  --tileShadow: rgba(0,0,0,.35);
}
*{box-sizing:border-box}
/* ä¿®å¤ï¼šæ”¯æŒç«–ç›´æ»šåŠ¨ï¼Œæœ€å°é«˜åº¦é€‚é…è§†å£ */
html,body{min-height:100vh; margin:0; padding:0;}
body{
  margin:0;
  color:var(--paper);
  background:
    radial-gradient(circle at 20% 20%, rgba(255,176,0,.12), transparent 40%),
    radial-gradient(circle at 80% 30%, rgba(255,59,122,.10), transparent 45%),
    linear-gradient(145deg, var(--bg1), var(--bg2));
  display:flex;
  align-items:flex-start;
  justify-content:center;
  padding:18px;
  overflow-y:auto; /* æ–°å¢ï¼šå¼ºåˆ¶å¼€å¯ç«–ç›´æ»šåŠ¨æ”¯æŒ */
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
}
.shell{
  width:min(820px, 96vw);
  border:3px solid rgba(247,241,213,.25);
  border-radius:18px;
  background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(0,0,0,.08));
  box-shadow: 0 16px 40px rgba(0,0,0,.55);
  overflow:hidden;
  position:relative;
}
.shell:before{
  content:"";
  position:absolute; inset:0;
  background:
    linear-gradient(rgba(255,255,255,.04) 1px, transparent 1px) 0 0 / 100% 3px;
  opacity:.22;
  pointer-events:none;
}
.header{
  padding:16px 18px;
  display:flex;
  gap:12px;
  align-items:flex-end;
  justify-content:space-between;
  border-bottom:1px solid rgba(247,241,213,.18);
  flex-wrap:wrap; /* æ–°å¢ï¼šå°å±å¹•æ ‡é¢˜è‡ªåŠ¨æ¢è¡Œ */
}
h1{
  margin:0;
  font-family:"Press Start 2P", system-ui, sans-serif;
  font-size:18px;
  letter-spacing:1px;
  line-height:1.25;
}
.sub{
  margin-top:8px;
  font-size:12px;
  opacity:.85;
}
.badges{
  display:flex; gap:8px; flex-wrap:wrap;
  align-items:center; justify-content:flex-end;
}
.badge{
  font-size:11px;
  padding:8px 10px;
  border-radius:999px;
  border:1px solid rgba(247,241,213,.22);
  background: rgba(0,0,0,.18);
}
.main{
  display:grid;
  grid-template-columns: 1fr 320px;
  gap:16px;
  padding:16px;
}
@media (max-width: 760px){
  .main{grid-template-columns:1fr; }
}
.panel{
  border:1px solid rgba(247,241,213,.18);
  border-radius:14px;
  background: rgba(0,0,0,.18);
  padding:14px;
}
/* é‡æ„ï¼šæ£‹ç›˜å®Œå…¨è‡ªé€‚åº”ï¼Œä¿è¯æ¨ªå‘100%æ˜¾ç¤ºå®Œæ•´ */
#game{
  display:grid;
  grid-template-columns: repeat(4, 1fr); /* 4åˆ—ç­‰å®½ï¼Œè‡ªé€‚åº”å®¹å™¨å®½åº¦ */
  gap:10px;
  width:100%; /* æ’‘æ»¡çˆ¶å®¹å™¨ï¼Œä¸æº¢å‡º */
  max-width:400px; /* å¤§å±å¹•é™åˆ¶æœ€å¤§å®½åº¦ï¼Œä¿æŒç¾è§‚ */
  aspect-ratio:1/1; /* æ•´ä½“æ­£æ–¹å½¢ï¼Œä¿è¯æ ¼å­æ¯”ä¾‹ */
  margin:0 auto; /* æ°´å¹³å±…ä¸­ */
  padding:16px;
  border-radius:16px;
  background:
    radial-gradient(circle at 10% 10%, rgba(255,255,255,.06), transparent 55%),
    linear-gradient(180deg, rgba(255,255,255,.05), rgba(0,0,0,.12));
  border:1px solid rgba(247,241,213,.14);
}
/* å°å±å¹•é€‚é…è°ƒæ•´ */
@media (max-width: 420px){
  #game{ gap:8px; padding:12px; }
}
/* é‡æ„ï¼šæ ¼å­è‡ªé€‚åº”æ­£æ–¹å½¢ï¼Œå­—ä½“é€‚é…å±å¹• */
.tile{
  border-radius:14px;
  background: linear-gradient(180deg, var(--tile), var(--tile2));
  border:2px solid rgba(27,26,23,.45);
  box-shadow:
    0 8px 0 rgba(0,0,0,.25),
    0 18px 24px var(--tileShadow);
  display:flex;
  align-items:center;
  justify-content:center;
  cursor:pointer;
  user-select:none;
  transform: translateY(0);
  transition: transform .10s ease, filter .12s ease;
  color: var(--ink);
  font-family:"Press Start 2P", system-ui, sans-serif;
  font-size:clamp(14px, 4.5vw, 20px); /* å­—ä½“è‡ªé€‚åº”ï¼Œå°å±å¹•ä¸æº¢å‡º */
  aspect-ratio:1/1; /* å¼ºåˆ¶æ­£æ–¹å½¢ï¼Œé€‚é…æ‰€æœ‰å±å¹• */
  width:100%; /* æ’‘æ»¡gridæ ¼å­ */
}
.tile:hover{ transform: translateY(-2px); filter: brightness(1.03); }
.tile:active{ transform: translateY(2px); }
.empty{
  background: transparent !important;
  border:2px dashed rgba(247,241,213,.20);
  box-shadow:none;
  cursor:default;
}
.controls{
  display:flex;
  flex-direction:column;
  gap:12px;
}
button{
  width:100%;
  padding:12px 12px;
  border-radius:12px;
  border:1px solid rgba(247,241,213,.20);
  background: linear-gradient(180deg, rgba(255,176,0,.26), rgba(255,176,0,.12));
  color: var(--paper);
  cursor:pointer;
  font-size:13px;
  font-weight:700;
  letter-spacing:.3px;
  box-shadow: 0 10px 22px rgba(0,0,0,.35);
}
button:hover:enabled{ filter: brightness(1.06); }
button:disabled{
  opacity:.45;
  cursor:not-allowed;
  box-shadow:none;
}
button.secondary{
  background: linear-gradient(180deg, rgba(255,59,122,.22), rgba(255,59,122,.12));
}
button.ghost{
  background: rgba(0,0,0,.15);
}
.row{
  display:flex;
  gap:10px;
}
.row > *{ flex:1; }
.hr{
  height:1px; background: rgba(247,241,213,.15);
  margin:8px 0 2px;
}
#status{
  font-size:12px;
  line-height:1.45;
  min-height:2.4em;
  opacity:.92;
}
.progressWrap{
  margin-top:8px;
  padding:10px;
  border-radius:12px;
  border:1px solid rgba(247,241,213,.16);
  background: rgba(0,0,0,.16);
  display:none;
}
.progressTop{
  display:flex; justify-content:space-between; align-items:center;
  font-size:11px; opacity:.9; gap:10px;
}
.progressBar{
  margin-top:8px;
  height:12px;
  border-radius:999px;
  border:1px solid rgba(247,241,213,.18);
  overflow:hidden;
  background: rgba(0,0,0,.25);
}
.progressFill{
  height:100%;
  width:0%;
  background: linear-gradient(90deg, rgba(255,176,0,.95), rgba(255,59,122,.85));
  transition: width .18s ease;
}
.small{
  font-size:11px; opacity:.85;
}
.pill{
  display:inline-flex;
  align-items:center;
  gap:8px;
  padding:10px 10px;
  border-radius:12px;
  border:1px solid rgba(247,241,213,.18);
  background: rgba(0,0,0,.16);
  font-size:12px;
}
.pill input{ transform: translateY(1px); }
.previewPanel{
  display:none;
  padding-top:6px;
}
.previewHint{
  font-size:11px; opacity:.85; margin-top:6px;
}
.kbd{
  font-family: ui-monospace, monospace;
  padding:2px 6px;
  border-radius:6px;
  border:1px solid rgba(247,241,213,.22);
  background: rgba(0,0,0,.25);
  font-size:11px;
}
.footer{
  padding:12px 16px 16px;
  border-top:1px solid rgba(247,241,213,.14);
  display:flex;
  gap:10px;
  flex-wrap:wrap;
  align-items:center;
  justify-content:space-between;
  font-size:11px;
  opacity:.85;
}
a{ color: var(--accent); text-decoration:none; }
a:hover{ text-decoration:underline; }
</style>
</head>
<body>
  <div class="shell">
    <div class="header">
      <div>
        <h1>æ•°å­—åå®¹é“ Â· å¤å¤æœºå°</h1>
        <div class="sub">AI ç ´è§£å°†<strong>åå°</strong>è¿è¡Œï¼›ç ´è§£å®Œæˆåè‡ªåŠ¨è¿›å…¥é¢„è§ˆæ¨¡å¼ã€‚é¢„è§ˆå¼€å§‹åå°†é”å®šæ“ä½œã€‚</div>
      </div>
      <div class="badges">
        <div class="badge" id="modeBadge">æ¨¡å¼ï¼šæ¸¸ç©</div>
        <div class="badge" id="cpuBadge">AIï¼šå¾…å‘½</div>
      </div>
    </div>
    <div class="main">
      <div class="panel">
        <div id="game" aria-label="Puzzle board"></div>
        <div class="small" style="margin-top:10px; opacity:.85;">
          å°æŠ€å·§ï¼šé¢„è§ˆä¸­å¯ç”¨é”®ç›˜ <span class="kbd">â†</span> é€€ä¸€æ­¥ã€<span class="kbd">â†’</span> å‰è¿›ä¸€æ­¥ã€<span class="kbd">Space</span> è‡ªåŠ¨æ’­æ”¾/æš‚åœã€‚
        </div>
      </div>
      <div class="panel controls">
        <div>
          <div class="row">
            <button id="shuffleBtn">é‡æ–°æ´—ç‰Œ</button>
            <button id="solveBtn" class="secondary">AI ç ´è§£</button>
          </div>
          <div class="hr"></div>
          <div id="status"></div>
          <div class="progressWrap" id="progressWrap">
            <div class="progressTop">
              <div id="progressText">ç ´è§£è¿›åº¦</div>
              <div id="progressPct">0%</div>
            </div>
            <div class="progressBar">
              <div class="progressFill" id="progressFill"></div>
            </div>
            <div class="small" id="progressMeta" style="margin-top:8px;"></div>
          </div>
        </div>
        <div class="previewPanel" id="previewPanel">
          <div class="hr"></div>
          <button id="startPreviewBtn">å¼€å§‹ç ´è§£é¢„è§ˆ</button>
          <div class="pill" style="margin-top:10px;">
            <input type="checkbox" id="autoPlayChk" />
            <label for="autoPlayChk">è‡ªåŠ¨æ’­æ”¾</label>
          </div>
          <div class="row" style="margin-top:10px;">
            <button id="backBtn" class="ghost">é€€ä¸€æ­¥</button>
            <button id="forwardBtn" class="ghost">å‰è¿›ä¸€æ­¥</button>
          </div>
          <div class="previewHint" id="previewHint"></div>
        </div>
        <div class="hr"></div>
        <div class="small">
          æœ¬åœ°è‡ªåŠ¨å­˜æ¡£ï¼šè¯¯å…³/åˆ·æ–°åä¼šå›åˆ°ä¸Šæ¬¡æ‰€åœ¨é¡µé¢ï¼›ä½†è‹¥ä¸Šæ¬¡ç ´è§£æœªå®Œæˆï¼Œå°†æç¤ºâ€œéœ€è¦é‡æ–°ç ´è§£â€å¹¶ä¿ç•™å±€é¢ã€‚
        </div>
      </div>
    </div>
    <div class="footer">
      <div>Â© Retro Puzzle Console</div>
      <div>ä¿å­˜é”®ï¼š<span class="kbd">localStorage</span></div>
    </div>
  </div>
<script>
/* =========================
   åŸºç¡€ï¼šæ£‹ç›˜é€»è¾‘
========================= */
const SIZE = 4, N = SIZE * SIZE;
const LS_KEY = "npuzzle_retro_v1";
let state = [];                // å½“å‰æ£‹ç›˜
let mode = "play";             // play | solving | ready | preview
let solutionMoves = null;      // ç ´è§£åçš„ move åˆ—è¡¨ï¼ˆæ¯æ­¥ç§»åŠ¨çš„æ•°å­—ï¼‰
let solutionStartState = null; // ç”ŸæˆsolutionMovesæ—¶çš„åˆå§‹æ£‹ç›˜çŠ¶æ€
let previewIndex = 0;          // å½“å‰é¢„è§ˆè¿›åº¦ï¼ˆ0 = èµ·ç‚¹ï¼‰
let autoPlay = false;
let autoTimer = null;
let interruptedSolve = false;
const $ = (id) => document.getElementById(id);
const game = $("game");
const shuffleBtn = $("shuffleBtn");
const solveBtn = $("solveBtn");
const statusDiv = $("status");
const modeBadge = $("modeBadge");
const cpuBadge = $("cpuBadge");
const progressWrap = $("progressWrap");
const progressFill = $("progressFill");
const progressPct = $("progressPct");
const progressText = $("progressText");
const progressMeta = $("progressMeta");
const previewPanel = $("previewPanel");
const startPreviewBtn = $("startPreviewBtn");
const autoPlayChk = $("autoPlayChk");
const backBtn = $("backBtn");
const forwardBtn = $("forwardBtn");
const previewHint = $("previewHint");
function isGoal(arr) {
  return arr.every((v,i) => (i < N-1 ? v === i+1 : v === 0));
}
function manhattan(arr){
  return arr.reduce((sum, v, i) => {
    if (v === 0) return sum;
    const tx = (v-1) % SIZE, ty = Math.floor((v-1)/SIZE);
    const cx = i % SIZE, cy = Math.floor(i/SIZE);
    return sum + Math.abs(tx-cx) + Math.abs(ty-cy);
  }, 0);
}
function isSolvable(arr) {
  let inv = 0;
  for (let i = 0; i < N; i++) {
    if (arr[i] === 0) continue;
    for (let j = i + 1; j < N; j++) {
      if (arr[j] !== 0 && arr[i] > arr[j]) inv++;
    }
  }
  const rowFromTop = Math.floor(arr.indexOf(0) / SIZE) + 1;
  return (SIZE % 2 === 1) ? (inv % 2 === 0) : ((inv + rowFromTop) % 2 === 0);
}
// é‡æ–°æ´—ç‰Œï¼šå…¨çŠ¶æ€é‡ç½®ï¼Œéšæ—¶å¯ç”¨
function shuffle(){
  // å¼ºåˆ¶ç»ˆæ­¢æ‰€æœ‰è¿è¡Œä¸­çš„è¿›ç¨‹
  stopAutoPlay();
  stopWorker();
  // å®Œå…¨æ¸…ç©ºæ‰€æœ‰ç ´è§£ã€é¢„è§ˆç›¸å…³æ•°æ®
  solutionMoves = null;
  solutionStartState = null;
  previewIndex = 0;
  previewStartState = null;
  previewStatesCache = null;
  autoPlay = false;
  interruptedSolve = false;
  // ç”Ÿæˆæ–°çš„å¯è§£éšæœºæ£‹ç›˜
  do {
    state = Array.from({length: N}, (_, i) => i);
    for (let i = N-1; i > 0; i--) {
      const j = (Math.random() * (i+1)) | 0;
      [state[i], state[j]] = [state[j], state[i]];
    }
  } while (!isSolvable(state) || isGoal(state));
  // é‡ç½®UIåˆ°åˆå§‹æ¸¸ç©çŠ¶æ€
  setMode("play");
  setStatus("");
  setProgressVisible(false);
  previewPanel.style.display = "none";
  // å­˜æ¡£å¹¶æ¸²æŸ“
  save();
  render();
}
function render(){
  game.innerHTML = "";
  state.forEach((v, i) => {
    const div = document.createElement("div");
    div.className = "tile" + (v === 0 ? " empty" : "");
    div.textContent = v === 0 ? "" : v;
    if (v !== 0) {
      div.addEventListener("click", () => {
        // ä»…æ¸¸ç©æ¨¡å¼å…è®¸æ‰‹åŠ¨æ“ä½œ
        if (mode !== "play") return;
        tryMove(i);
      });
    }
    game.appendChild(div);
  });
}
function tryMove(idx){
  const x = idx % SIZE, y = Math.floor(idx / SIZE);
  const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
  for (const [dx,dy] of dirs) {
    const nx = x + dx, ny = y + dy;
    if (nx>=0 && nx<SIZE && ny>=0 && ny<SIZE) {
      const ni = ny*SIZE + nx;
      if (state[ni] === 0) {
        [state[idx], state[ni]] = [state[ni], state[idx]];
        save();
        render();
        // ä»…æ‰‹åŠ¨ç§»åŠ¨å®Œæˆæ—¶å¼¹å‡ºæç¤º
        if (isGoal(state)) {
          setTimeout(() => alert("æ­å–œï¼æ‹¼å›¾å·²å®Œæˆ ğŸ‰"), 60);
        }
        return true;
      }
    }
  }
  return false;
}
/* =========================
   å­˜æ¡£ / æ¢å¤
========================= */
function save(){
  const payload = {
    v: 1,
    state,
    mode,
    solutionMoves,
    solutionStartState,
    previewIndex,
    autoPlay,
    interruptedSolve
  };
  try{ localStorage.setItem(LS_KEY, JSON.stringify(payload)); }catch(e){}
}
function load(){
  try{
    const raw = localStorage.getItem(LS_KEY);
    if (!raw) return false;
    const data = JSON.parse(raw);
    if (!data || data.v !== 1) return false;
    // æ¢å¤åŸºç¡€æ•°æ®
    state = Array.isArray(data.state) && data.state.length === N ? data.state : [];
    mode = data.mode || "play";
    solutionMoves = data.solutionMoves || null;
    solutionStartState = Array.isArray(data.solutionStartState) && data.solutionStartState.length === N ? data.solutionStartState : null;
    previewIndex = Number.isFinite(data.previewIndex) ? data.previewIndex : 0;
    autoPlay = !!data.autoPlay;
    interruptedSolve = !!data.interruptedSolve;
    // æ ¡éªŒç ´è§£æ•°æ®é…å¯¹ï¼Œæ— æ•ˆæ•°æ®è‡ªåŠ¨æ¸…ç©º
    if (solutionMoves && !solutionStartState) {
      solutionMoves = null;
      previewIndex = 0;
      autoPlay = false;
      mode = "play";
    }
    // ç ´è§£ä¸­æ–­å¤„ç†
    if (mode === "solving") {
      interruptedSolve = true;
      mode = "play";
      solutionMoves = null;
      solutionStartState = null;
      previewIndex = 0;
      autoPlay = false;
    }
    return true;
  }catch(e){
    return false;
  }
}
/* =========================
   UI çŠ¶æ€
========================= */
function setMode(next){
  mode = next;
  const label = ({
    play: "æ¨¡å¼ï¼šæ¸¸ç©",
    solving: "æ¨¡å¼ï¼šAI ç ´è§£ä¸­",
    ready: "æ¨¡å¼ï¼šå·²ç ´è§£ï¼ˆå¾…é¢„è§ˆï¼‰",
    preview: "æ¨¡å¼ï¼šç ´è§£é¢„è§ˆï¼ˆé”å®šï¼‰"
  })[mode] || "æ¨¡å¼ï¼šæ¸¸ç©";
  modeBadge.textContent = label;
  // æŒ‰é’®é”å®šç­–ç•¥ï¼šæ´—ç‰ŒæŒ‰é’®æ°¸ä¹…å¯ç”¨ï¼Œä»…é™åˆ¶å…¶ä»–æŒ‰é’®
  solveBtn.disabled = (mode === "solving" || mode === "preview");
  // readyæ¨¡å¼å…è®¸é‡æ–°ç ´è§£
  if (mode === "ready") solveBtn.disabled = false;
  // é¢„è§ˆé¢æ¿æ˜¾ç¤ºæ§åˆ¶
  previewPanel.style.display = (mode === "ready" || mode === "preview") ? "block" : "none";
  // é¢„è§ˆæŒ‰é’®æ§åˆ¶
  const canStep = (mode === "preview");
  backBtn.disabled = !canStep;
  forwardBtn.disabled = !canStep;
  autoPlayChk.disabled = !canStep;
  // AIçŠ¶æ€æ˜¾ç¤º
  cpuBadge.textContent = (mode === "solving") ? "AIï¼šä½å ç”¨ï¼ˆåå°ï¼‰" : "AIï¼šå¾…å‘½";
  save();
}
function setStatus(text){
  statusDiv.textContent = text;
  save();
}
function setProgressVisible(visible){
  progressWrap.style.display = visible ? "block" : "none";
}
function setProgress(percent, metaText){
  const p = Math.max(0, Math.min(100, percent|0));
  progressFill.style.width = p + "%";
  progressPct.textContent = p + "%";
  progressMeta.textContent = metaText || "";
}
/* =========================
   AI ç ´è§£ï¼šWeb Worker
========================= */
let worker = null;
function makeWorker(){
  const workerCode = `
  const SIZE=4, N=16;
  function isGoal(a){
    for(let i=0;i<N-1;i++) if(a[i]!==i+1) return false;
    return a[N-1]===0;
  }
  function manhattan(a){
    let s=0;
    for(let i=0;i<N;i++){
      const v=a[i];
      if(v===0) continue;
      const tx=(v-1)%SIZE, ty=((v-1)/SIZE)|0;
      const cx=i%SIZE, cy=(i/SIZE)|0;
      s += Math.abs(tx-cx)+Math.abs(ty-cy);
    }
    return s;
  }
  function linearConflict(a){
    let lc=0;
    for(let r=0;r<SIZE;r++){
      const row = a.slice(r*SIZE, r*SIZE+SIZE);
      for(let i=0;i<SIZE;i++){
        const v1=row[i];
        if(v1===0) continue;
        const goalR=((v1-1)/SIZE)|0;
        if(goalR!==r) continue;
        const goalC1=(v1-1)%SIZE;
        for(let j=i+1;j<SIZE;j++){
          const v2=row[j];
          if(v2===0) continue;
          const goalR2=((v2-1)/SIZE)|0;
          if(goalR2!==r) continue;
          const goalC2=(v2-1)%SIZE;
          if(goalC1>goalC2) lc += 2;
        }
      }
    }
    for(let c=0;c<SIZE;c++){
      const col = [a[c],a[c+SIZE],a[c+2*SIZE],a[c+3*SIZE]];
      for(let i=0;i<SIZE;i++){
        const v1=col[i];
        if(v1===0) continue;
        const goalC=(v1-1)%SIZE;
        if(goalC!==c) continue;
        const goalR1=((v1-1)/SIZE)|0;
        for(let j=i+1;j<SIZE;j++){
          const v2=col[j];
          if(v2===0) continue;
          const goalC2=(v2-1)%SIZE;
          if(goalC2!==c) continue;
          const goalR2=((v2-1)/SIZE)|0;
          if(goalR1>goalR2) lc += 2;
        }
      }
    }
    return lc;
  }
  function h(a){ return manhattan(a) + linearConflict(a); }
  function neighbors(a, z){
    const res=[];
    const zx=z%SIZE, zy=(z/SIZE)|0;
    const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
    for(const [dx,dy] of dirs){
      const nx=zx+dx, ny=zy+dy;
      if(nx<0||nx>=SIZE||ny<0||ny>=SIZE) continue;
      const ni=ny*SIZE+nx;
      const b=a.slice();
      const moved=b[ni];
      b[z]=moved; b[ni]=0;
      res.push({next:b, moved, z2:ni});
    }
    return res;
  }
  function idaSolve(start){
    const startZ = start.indexOf(0);
    let bound = h(start);
    const pathMoves=[];
    const pathStates=[start.slice()];
    const pathZ=[startZ];
    let nodes=0, iter=0;
    const seen = new Set();
    function key(a){ return a.join(','); }
    function dfs(g, bound){
      const a = pathStates[pathStates.length-1];
      const f = g + h(a);
      if(f>bound) return f;
      if(isGoal(a)) return true;
      let min = Infinity;
      const z = pathZ[pathZ.length-1];
      const neigh = neighbors(a, z).sort((p,q)=>h(p.next)-h(q.next));
      for(const nb of neigh){
        if(pathMoves.length>0 && nb.moved === pathMoves[pathMoves.length-1]) {
          if(pathStates.length>=2){
            const prev = pathStates[pathStates.length-2];
            let same=true;
            for(let i=0;i<N;i++){ if(prev[i]!==nb.next[i]){same=false;break;} }
            if(same) continue;
          }
        }
        const k = key(nb.next);
        if(seen.has(k)) continue;
        seen.add(k);
        pathStates.push(nb.next);
        pathZ.push(nb.z2);
        pathMoves.push(nb.moved);
        nodes++;
        if((nodes & 8191) === 0) {
          postMessage({type:"progress", bound, iter, nodes});
        }
        const t = dfs(g+1, bound);
        if(t === true) return true;
        if(t < min) min = t;
        pathMoves.pop();
        pathZ.pop();
        pathStates.pop();
        seen.delete(k);
      }
      return min;
    }
    seen.add(key(start));
    while(true){
      iter++;
      postMessage({type:"progress", bound, iter, nodes});
      const t = dfs(0, bound);
      if(t === true){
        return {moves:pathMoves.slice(), nodes, iter, bound};
      }
      if(t === Infinity){
        throw new Error("æ— è§£");
      }
      bound = t;
    }
  }
  onmessage = (e)=>{
    const msg=e.data||{};
    if(msg.type==="solve"){
      try{
        const start=msg.start;
        const t0=Date.now();
        const res=idaSolve(start);
        const ms=Date.now()-t0;
        postMessage({type:"done", ...res, ms});
      }catch(err){
        postMessage({type:"error", message: String(err && err.message ? err.message : err)});
      }
    }
  };
  `;
  const blob = new Blob([workerCode], {type:"application/javascript"});
  return new Worker(URL.createObjectURL(blob));
}
function stopWorker(){
  if(worker){
    worker.terminate();
    worker = null;
  }
}
function computePercentFromProgress(p){
  const iter = p.iter || 1;
  const bound = p.bound || 0;
  let base = 1 - Math.exp(-iter/3);
  let bump = 1 - Math.exp(-bound/18);
  let pct = Math.floor((0.55*base + 0.45*bump) * 99);
  if(!Number.isFinite(pct)) pct = 1;
  return Math.max(1, Math.min(99, pct));
}
async function startSolve(){
  if (mode === "preview") return;
  if (isGoal(state)) { alert("å·²ç»å®Œæˆï¼Œæ— éœ€ç ´è§£ï¼"); return; }
  stopAutoPlay();
  stopWorker();
  setMode("solving");
  setStatus("AI æ­£åœ¨åå°ç ´è§£â€¦ï¼ˆä½ ä»å¯æµè§ˆé¡µé¢ï¼Œä½†æ‹¼å›¾æ“ä½œè¢«é”å®šï¼‰");
  setProgressVisible(true);
  progressText.textContent = "ç ´è§£è¿›åº¦ï¼ˆä¼°ç®—ï¼‰";
  setProgress(1, "å‡†å¤‡ä¸­â€¦");
  interruptedSolve = false;
  save();
  worker = makeWorker();
  worker.onmessage = (e)=>{
    const m=e.data||{};
    if(m.type==="progress"){
      const pct = computePercentFromProgress(m);
      setProgress(pct, `è¿­ä»£ï¼š${m.iter}  Â·  æœç´¢èŠ‚ç‚¹ï¼š${m.nodes.toLocaleString()}  Â·  å½“å‰é˜ˆå€¼(bound)ï¼š${m.bound}`);
    }else if(m.type==="done"){
      setProgress(100, `å®Œæˆï¼è¿­ä»£ï¼š${m.iter} Â· èŠ‚ç‚¹ï¼š${m.nodes.toLocaleString()} Â· ç”¨æ—¶ï¼š${m.ms}ms`);
      // ä¿å­˜ç ´è§£ç»“æœä¸åˆå§‹çŠ¶æ€
      solutionMoves = m.moves;
      solutionStartState = state.slice();
      previewIndex = 0;
      // æ ‡è®°ä¸ºå°±ç»ªï¼Œè‡ªåŠ¨è¿›å…¥é¢„è§ˆ
      setMode("ready");
      setStatus("ç ´è§£å·²å®Œæˆ âœ… è‡ªåŠ¨è¿›å…¥é¢„è§ˆæ¨¡å¼...");
      save();
      stopWorker();
      // è‡ªåŠ¨è¿›å…¥é¢„è§ˆï¼ŒçŸ­å»¶è¿Ÿä¿è¯ç”¨æˆ·çœ‹åˆ°å®Œæˆæç¤º
      setTimeout(() => {
        startPreview();
      }, 300);
    }else if(m.type==="error"){
      setMode("play");
      setStatus("ç ´è§£å¤±è´¥ï¼š" + m.message);
      setProgressVisible(false);
      stopWorker();
      save();
      alert("ç ´è§£å¤±è´¥ï¼š" + m.message);
    }
  };
  worker.postMessage({type:"solve", start: state.slice()});
}
/* =========================
   é¢„è§ˆï¼šé€æ­¥æ’­æ”¾ã€å›çœ‹
========================= */
let previewStartState = null;
let previewStatesCache = null;
function applyMove(arr, moved){
  const z = arr.indexOf(0);
  const i = arr.indexOf(moved);
  if (z === -1 || i === -1) return arr;
  const zx = z % SIZE, zy = (z / SIZE) | 0;
  const ix = i % SIZE, iy = (i / SIZE) | 0;
  const man = Math.abs(zx-ix) + Math.abs(zy-iy);
  if(man !== 1) return arr;
  const b = arr.slice();
  b[z] = moved;
  b[i] = 0;
  return b;
}
function ensurePreviewCache(){
  if(!solutionMoves || !Array.isArray(solutionMoves) || !solutionStartState) return false;
  if(!previewStartState) previewStartState = solutionStartState.slice();
  if(!previewStatesCache){
    previewStatesCache = [previewStartState.slice()];
  }
  return true;
}
function buildStateUpTo(k){
  if(!ensurePreviewCache()) return;
  while(previewStatesCache.length <= k){
    const idx = previewStatesCache.length - 1;
    const prev = previewStatesCache[idx];
    const moved = solutionMoves[idx];
    const next = applyMove(prev, moved);
    previewStatesCache.push(next);
  }
}
function goToPreviewIndex(k){
  if(!solutionMoves) return;
  const max = solutionMoves.length;
  k = Math.max(0, Math.min(max, k));
  buildStateUpTo(k);
  previewIndex = k;
  state = previewStatesCache[k].slice();
  render();
  const done = (previewIndex === max);
  previewHint.textContent = done
    ? "å·²åˆ°ç»ˆç‚¹ï¼ˆå®Œæˆï¼‰ã€‚ä»å¯é€€ä¸€æ­¥å›çœ‹ã€‚"
    : `ç¬¬ ${previewIndex} / ${max} æ­¥ï¼ˆæ¯ä¸€æ­¥å‡å·²è®°å½•ï¼Œå¯å›çœ‹ï¼‰`;
  save();
}
function startPreview(){
  if(mode !== "ready" && mode !== "preview") return;
  if(!solutionMoves || !solutionStartState) return;
  // è¿›å…¥é¢„è§ˆæ¨¡å¼ï¼Œé”å®šæ“ä½œ
  setMode("preview");
  setStatus("é¢„è§ˆè¿›è¡Œä¸­ï¼šæ“ä½œå·²é”å®šï¼ˆç‚¹å‡»é‡æ–°æ´—ç‰Œå¯é‡ç½®ï¼‰ã€‚");
  // å›ºå®šé¢„è§ˆèµ·ç‚¹ä¸ºç ´è§£åˆå§‹çŠ¶æ€
  previewStartState = solutionStartState.slice();
  previewStatesCache = [previewStartState.slice()];
  goToPreviewIndex(previewIndex || 0);
  autoPlayChk.checked = !!autoPlay;
  backBtn.disabled = false;
  forwardBtn.disabled = false;
  autoPlayChk.disabled = false;
  if(autoPlay) startAutoPlay();
}
function stepForward(){
  if(mode !== "preview") return;
  goToPreviewIndex(previewIndex + 1);
  if(previewIndex === solutionMoves.length){
    stopAutoPlay();
    autoPlayChk.checked = false;
    autoPlay = false;
    save();
  }
}
function stepBack(){
  if(mode !== "preview") return;
  stopAutoPlay();
  autoPlayChk.checked = false;
  autoPlay = false;
  save();
  goToPreviewIndex(previewIndex - 1);
}
function startAutoPlay(){
  stopAutoPlay();
  if(mode !== "preview") return;
  autoPlay = true;
  save();
  autoTimer = setInterval(()=>{
    if(previewIndex >= solutionMoves.length){
      stopAutoPlay();
      autoPlayChk.checked = false;
      autoPlay = false;
      save();
      return;
    }
    stepForward();
  }, 180);
}
function stopAutoPlay(){
  if(autoTimer){
    clearInterval(autoTimer);
    autoTimer = null;
  }
}
/* =========================
   äº‹ä»¶ç»‘å®š
========================= */
shuffleBtn.addEventListener("click", shuffle);
solveBtn.addEventListener("click", ()=>startSolve());
startPreviewBtn.addEventListener("click", startPreview);
autoPlayChk.addEventListener("change", ()=>{
  if(mode !== "preview") return;
  autoPlay = autoPlayChk.checked;
  save();
  if(autoPlay) startAutoPlay();
  else stopAutoPlay();
});
backBtn.addEventListener("click", stepBack);
forwardBtn.addEventListener("click", stepForward);
window.addEventListener("beforeunload", ()=>{
  if(mode === "solving"){
    interruptedSolve = true;
    mode = "solving";
    save();
  }else{
    save();
  }
});
// é”®ç›˜å¿«æ·é”®
window.addEventListener("keydown", (e)=>{
  const target = e.target;
  if (target.tagName === "INPUT" || target.tagName === "BUTTON" || target.tagName === "TEXTAREA" || target.isContentEditable) {
    return;
  }
  if(mode !== "preview") return;
  if(e.key === "ArrowLeft"){ e.preventDefault(); stepBack(); }
  else if(e.key === "ArrowRight"){ e.preventDefault(); stepForward(); }
  else if(e.key === " "){ e.preventDefault();
    autoPlayChk.checked = !autoPlayChk.checked;
    autoPlayChk.dispatchEvent(new Event("change"));
  }
});
/* =========================
   å¯åŠ¨ï¼šæ¢å¤æˆ–æ´—ç‰Œ
========================= */
(function init(){
  const ok = load();
  if(!ok || !Array.isArray(state) || state.length !== N){
    shuffle();
    return;
  }
  render();
  if(interruptedSolve){
    setStatus("æ£€æµ‹åˆ°ä¸Šæ¬¡ç ´è§£æœªå®Œæˆï¼šéœ€è¦é‡æ–°ç ´è§£ï¼ˆå±€é¢å·²ä¿ç•™ï¼‰ã€‚");
    setProgressVisible(false);
    previewPanel.style.display = "none";
    interruptedSolve = false;
    save();
  }
  // æ¢å¤UIçŠ¶æ€
  if(mode === "play"){
    setMode("play");
    setProgressVisible(false);
    previewPanel.style.display = "none";
  }else if(mode === "ready"){
    setMode("ready");
    setProgressVisible(false);
    previewPanel.style.display = "block";
    setStatus(statusDiv.textContent || "ç ´è§£å·²å®Œæˆ âœ… ç‚¹å‡»ã€Œå¼€å§‹ç ´è§£é¢„è§ˆã€æŸ¥çœ‹ã€‚");
  }else if(mode === "preview"){
    if(!solutionMoves || !solutionStartState){
      setMode("play");
      setStatus("é¢„è§ˆæ•°æ®ç¼ºå¤±ï¼Œéœ€è¦é‡æ–°ç ´è§£ã€‚");
      return;
    }
    setMode("preview");
    setProgressVisible(false);
    previewPanel.style.display = "block";
    previewStartState = solutionStartState.slice();
    previewStatesCache = [previewStartState.slice()];
    previewIndex = Math.max(0, Math.min(solutionMoves.length, previewIndex|0));
    goToPreviewIndex(previewIndex);
    autoPlayChk.checked = !!autoPlay;
    if(autoPlay) startAutoPlay();
    else stopAutoPlay();
    setStatus(statusDiv.textContent || "å·²æ¢å¤åˆ°ä¸Šæ¬¡é¢„è§ˆä½ç½®ã€‚");
  }else{
    setMode("play");
    setProgressVisible(false);
    previewPanel.style.display = "none";
  }
})();
</script>
</body>
</html>
